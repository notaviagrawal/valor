<!DOCTYPE html>
<html lang="en">

<head>
	<title>three.js webgl - materials - UltraHDR texture loader</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="main.css">
</head>

<body>

	<!-- Loading Screen -->
	<div id="loading-screen">
		<div id="loading-content">
			<h1 id="loading-title">valor</h1>
			<div id="loading-bar-container">
				<div id="loading-bar"></div>
			</div>
			<p id="loading-text">Loading environments...</p>
		</div>
	</div>

	<div id="info">
		<h1>valor</h1>
	</div>

	<script type="importmap">
			{
				"imports": {
					"three": "./build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

	<script type="module">

		import * as THREE from 'three';

		import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

		import { UltraHDRLoader } from 'three/addons/loaders/UltraHDRLoader.js';
		import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
		import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

		const params = {
			autoRotate: true,
			autoRotateBackground: true,
			metalness: 1.0,
			roughness: 0.0,
			exposure: 1.0,  // Adjusted for optimized textures
			backgroundImage: 'sunset-mountain.jpg',
			type: 'HalfFloatType'
		};

		// Available texture files - auto-generated from textures/equirectangular directory
		// To update this list when adding new textures, run: node generate-texture-list.js
		const availableTextures = [
			"aerial-mountain.jpg",
			"alien-planet.jpg",
			"bridge.jpg",
			"city-sunset.jpg",
			"cloudscape-sunset.jpg",
			"desert.jpg",
			"earth-space.jpg",
			"foggy-morning.jpg",
			"hilly-terrain.jpg",
			"pink-sunrise.jpg",
			"reflective-hall.jpg",
			"sci-fi-abstract.jpg",
			"sci-fi-planet.jpg",
			"shanghai.jpg",
			"sunflowers.jpg",
			"sunset-mountain.jpg",
			"sunset-ocean.jpg",
			"vaporwave.jpg"
		];

		let renderer, scene, camera, controls, model, pivotGroup, loader, gltfLoader;

		// Smart caching system
		const textureCache = new Map();
		const loadingTextures = new Set();
		let currentTextureIndex = 0;
		let backgroundRotationTimer = null;
		let nextTextureIndex = 1;
		let preloadTimer = null;
		let preloadIdleId = null;

		// GPU capability detection
		let maxTextureSize = 8192; // Safe default
		let selectedQuality = 'high'; // Will be set based on GPU capabilities

		// Preload first 6 scenes, then load rest in background
		const preloadedScenes = [
			"alien-planet.jpg",
			"desert.jpg",
			"sunflowers.jpg",
			"foggy-morning.jpg",
			"sci-fi-abstract.jpg",
			"city-sunset.jpg"
		];
		let remainingScenes = [];
		let allScenesLoaded = false;
		let currentSceneInRotation = 0;
		let currentRotationInterval = 5000; // 5 seconds always

		// Texture swap system
		let currentEnvTexture = null;
		let backgroundMesh = null;
		let backgroundMaterial = null;
		let backgroundRotationTimeout = null;

		init();

		function init() {

			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);

			renderer.toneMapping = THREE.ACESFilmicToneMapping;
			renderer.toneMappingExposure = params.exposure;
			renderer.outputColorSpace = THREE.SRGBColorSpace;

			renderer.setAnimationLoop(render);

			// Detect GPU capabilities
			const gl = renderer.getContext();
			maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
			console.log(`ðŸŽ® GPU Max Texture Size: ${maxTextureSize}x${maxTextureSize}`);

			// Select quality based on GPU capabilities
			if (maxTextureSize >= 16384) {
				selectedQuality = 'high'; // 10240Ã—5120 - Full quality
				console.log('âœ… Using HIGH quality textures (10240Ã—5120 @ 100%)');
			} else if (maxTextureSize >= 8192) {
				selectedQuality = 'high'; // Still use high, it fits
				console.log('âœ… Using HIGH quality textures (10240Ã—5120 @ 100%)');
			} else if (maxTextureSize >= 4096) {
				selectedQuality = 'medium'; // Fallback to medium
				console.log('âš ï¸ GPU limit reached, using MEDIUM quality (2048Ã—1024)');
			} else {
				selectedQuality = 'low';
				console.log('âš ï¸ Low GPU capability, using LOW quality');
			}

			scene = new THREE.Scene();

			// Fullscreen background quad for shader-based crossfade
			const bgGeo = new THREE.PlaneGeometry(2, 2);
			backgroundMaterial = new THREE.ShaderMaterial({
				uniforms: {
					texA: { value: null },
					texB: { value: null },
					mixAmount: { value: 0.0 }
				},
				vertexShader: `
					varying vec2 vUv;
					void main() {
						vUv = uv;
						gl_Position = vec4(position, 1.0);
					}
				`,
				fragmentShader: `
					precision highp float;
					varying vec2 vUv;
					uniform sampler2D texA;
					uniform sampler2D texB;
					uniform float mixAmount;
					void main() {
						vec3 a = texture2D(texA, vUv).rgb;
						vec3 b = texture2D(texB, vUv).rgb;
						gl_FragColor = vec4(mix(a, b, mixAmount), 1.0);
					}
				`,
				depthWrite: false,
				depthTest: false,
				transparent: false
			});
			backgroundMesh = new THREE.Mesh(bgGeo, backgroundMaterial);
			const bgScene = new THREE.Scene();
			bgScene.add(backgroundMesh);
			// Hook background render in main render loop
			renderer.autoClear = false;

			// Create pivot group for rotation
			pivotGroup = new THREE.Group();
			scene.add(pivotGroup);

			// Load GLTF model
			console.log('GLTFLoader:', GLTFLoader);
			gltfLoader = new GLTFLoader();
			gltfLoader.load('valerlogo.gltf', function (gltf) {
				model = gltf.scene;

				// Apply material to all meshes in the model
				model.traverse(function (child) {
					if (child.isMesh) {
						child.material = new THREE.MeshStandardMaterial({
							roughness: params.roughness,
							metalness: params.metalness
						});
					}
				});

				// Calculate bounding box of the original model
				const boundingBox = new THREE.Box3().setFromObject(model);

				// Get center of the original model
				const center = new THREE.Vector3();
				boundingBox.getCenter(center);

				// Move model to center it at origin (moves center to 0,0,0)
				model.position.sub(center);

				// Scale the model manually
				model.scale.setScalar(50);

				// Recalculate bounding box after scaling to get the new center
				const scaledBoundingBox = new THREE.Box3().setFromObject(model);
				const scaledCenter = new THREE.Vector3();
				scaledBoundingBox.getCenter(scaledCenter);

				// Move model again to ensure it's perfectly centered after scaling
				model.position.sub(scaledCenter);

				// Ensure pivot group is at origin
				pivotGroup.position.set(0, 0, 0);

				// Add model to pivot group
				pivotGroup.add(model);

				// Rotation (applied to pivot group)
				pivotGroup.rotation.x = -Math.PI / 2; // -90 degrees
				pivotGroup.rotation.y = 0;           // 0 degrees  
				pivotGroup.rotation.z = -Math.PI / 2; // -90 degrees

			});

			camera = new THREE.PerspectiveCamera(
				50,
				window.innerWidth / window.innerHeight,
				1,
				500
			);
			camera.position.set(0.0, 0.0, - 6.0);

			console.log('OrbitControls:', OrbitControls);
			controls = new OrbitControls(camera, renderer.domElement);

			loader = new UltraHDRLoader();
			loader.setDataType(THREE.FloatType);

			// Smart texture loading with caching and preloading
			// NOW USING OPTIMIZED TEXTURES from Step 1 build pipeline!
			const loadEnvironment = function (imageName = 'spruit_sunrise_4k.hdr.jpg', type = 'HalfFloatType', isPreload = false) {

				// Check if texture is already cached
				const cacheKey = `${imageName}_${type}`;
				if (textureCache.has(cacheKey)) {
					const texture = textureCache.get(cacheKey);
					if (!isPreload) {
						texture.mapping = THREE.EquirectangularReflectionMapping;
						texture.needsUpdate = true;
						scene.background = texture;
						scene.environment = texture;
					}
					return Promise.resolve(texture);
				}

				// Check if already loading
				if (loadingTextures.has(cacheKey)) {
					return new Promise((resolve) => {
						const checkLoading = () => {
							if (textureCache.has(cacheKey)) {
								resolve(textureCache.get(cacheKey));
							} else {
								setTimeout(checkLoading, 100);
							}
						};
						checkLoading();
					});
				}

				// Start loading
				loadingTextures.add(cacheKey);

				// Use optimized textures based on GPU capability
				const basename = imageName.replace(/\.(jpg|jpeg|png)$/i, '');
				const quality = selectedQuality; // Use detected quality level
				const ext = quality === 'high' ? 'jpg' : 'webp';
				const optimizedPath = `textures/processed/${quality}/${basename}.${ext}`;

				console.log(`ðŸ“¸ Loading texture: ${optimizedPath}`);

				// Use TextureLoader for optimized JPG/WebP files
				const textureLoader = new THREE.TextureLoader();

				return new Promise((resolve, reject) => {
					textureLoader.load(optimizedPath, function (texture) {
						texture.mapping = THREE.EquirectangularReflectionMapping;
						texture.colorSpace = THREE.SRGBColorSpace;
						texture.needsUpdate = true;

						// CRITICAL: Force GPU upload during preload to prevent blocking later!
						if (isPreload) {
							// Trigger GPU upload now by temporarily setting as background
							const oldBg = scene.background;
							scene.background = texture;
							renderer.renderLists.dispose(); // Force processing
							scene.background = oldBg;
						}

						// Cache the texture
						textureCache.set(cacheKey, texture);
						loadingTextures.delete(cacheKey);

						if (!isPreload) {
							scene.background = texture;
							scene.environment = texture;
						}

						resolve(texture);
					}, undefined, (error) => {
						console.warn(`Failed to load optimized texture: ${optimizedPath}, falling back...`);
						// Fallback to original if optimized doesn't exist
						loader.setDataType(THREE[type]);
						loader.load(`textures/equirectangular/${imageName}`, function (texture) {
							texture.mapping = THREE.EquirectangularReflectionMapping;
							texture.needsUpdate = true;
							textureCache.set(cacheKey, texture);
							loadingTextures.delete(cacheKey);
							if (!isPreload) {
								scene.background = texture;
								scene.environment = texture;
							}
							resolve(texture);
						}, undefined, reject);
					});
				});
			};

			// No longer needed - all textures preloaded during loading screen
			const preloadNextTexture = function () {
				// All textures already preloaded during loading screen!
			};

			// Shader-based crossfade (non-blocking)
			const crossfadeToTexture = function (newTexture) {
				if (!currentEnvTexture) {
					currentEnvTexture = newTexture;
					scene.background = newTexture;
					scene.environment = newTexture;
					return;
				}
				backgroundMaterial.uniforms.texA.value = currentEnvTexture;
				backgroundMaterial.uniforms.texB.value = newTexture;
				backgroundMaterial.uniforms.mixAmount.value = 0.0;
				const start = performance.now();
				const duration = 1000;
				const step = (t) => {
					const k = Math.min((t - start) / duration, 1);
					backgroundMaterial.uniforms.mixAmount.value = k;
					if (k < 1) {
						requestAnimationFrame(step);
					} else {
						currentEnvTexture = newTexture;
						scene.background = newTexture;
						scene.environment = newTexture;
					}
				};
				requestAnimationFrame(step);
			};

			// Clear any scheduled preload tasks
			const clearPreloadSchedule = function () {
				if (preloadTimer) {
					clearTimeout(preloadTimer);
					preloadTimer = null;
				}
				if (preloadIdleId && window.cancelIdleCallback) {
					cancelIdleCallback(preloadIdleId);
					preloadIdleId = null;
				}
			};

			// Schedule preloading mid-interval (~6s into the 10s cycle), using idle time
			const scheduleMidIntervalPreload = function (delayMs = 6000) {
				clearPreloadSchedule();
				preloadTimer = setTimeout(() => {
					if (window.requestIdleCallback) {
						preloadIdleId = requestIdleCallback(() => {
							preloadNextTexture();
						});
					} else {
						// Fallback: small timeout to avoid beginning-of-cycle spikes
						setTimeout(() => preloadNextTexture(), 0);
					}
				}, delayMs);
			};

			// Auto-rotate background function - FIXED to 5 seconds always!
			const rotateBackground = function () {
				if (!params.autoRotateBackground) return;

				// Cycle through all textures
				currentTextureIndex = nextTextureIndex;
				nextTextureIndex = (currentTextureIndex + 1) % availableTextures.length;
				const currentTextureName = availableTextures[currentTextureIndex];
				params.backgroundImage = currentTextureName;

				currentSceneInRotation++;

				// Trigger background loading when we hit scene 6 (halfway through)
				if (currentSceneInRotation === 6 && !allScenesLoaded) {
					console.log('ðŸ”„ Halfway through scene 6, starting background loading...');
					setTimeout(() => {
						loadRemainingScenes();
					}, 2500); // Halfway through the 5-second display (2.5s)
				}

				// Load texture (instant since preloaded) and crossfade
				loadEnvironment(currentTextureName, params.type).then((texture) => {
					crossfadeToTexture(texture);

					// Update GUI to reflect current texture
					gui.controllersRecursive().forEach(controller => {
						if (controller.property === 'backgroundImage') {
							controller.updateDisplay();
						}
					});
				});
			};

			// Start background rotation timer - ALWAYS 5 seconds!
			const startBackgroundRotation = function () {
				if (backgroundRotationTimer) {
					clearInterval(backgroundRotationTimer);
				}

				if (params.autoRotateBackground) {
					backgroundRotationTimer = setInterval(rotateBackground, 5000); // FIXED: Always 5 seconds
					console.log(`ðŸŽ¬ Background rotation started - 5 second intervals (all scenes)`);
				}
			};

			// Stop background rotation timer
			const stopBackgroundRotation = function () {
				if (backgroundRotationTimer) {
					clearInterval(backgroundRotationTimer);
					backgroundRotationTimer = null;
					console.log('Background rotation stopped');
				}
			};

			// Preload first 6 scenes only - fast startup!
			async function preloadInitialScenes() {
				const loadingBar = document.getElementById('loading-bar');
				const loadingText = document.getElementById('loading-text');

				// Calculate remaining scenes
				remainingScenes = availableTextures.filter(texture => !preloadedScenes.includes(texture));
				console.log(`ðŸŽ¬ Preloading first ${preloadedScenes.length} scenes for instant playback...`);
				console.log(`ðŸ“¦ ${remainingScenes.length} scenes will load in background`);

				for (let i = 0; i < preloadedScenes.length; i++) {
					const sceneName = preloadedScenes[i];
					loadingText.textContent = `Loading ${sceneName}...`;

					await loadEnvironment(sceneName, params.type, true);

					const progress = ((i + 1) / preloadedScenes.length) * 100;
					loadingBar.style.width = `${progress}%`;
				}

				loadingText.textContent = 'Ready!';
				console.log(`âœ… First ${preloadedScenes.length} scenes ready!`);

				// Wait a moment then fade out loading screen
				setTimeout(() => {
					const loadingScreen = document.getElementById('loading-screen');
					loadingScreen.classList.add('fade-out');

					// Remove from DOM after fade
					setTimeout(() => {
						loadingScreen.remove();

						// Start with first scene
						currentTextureIndex = 0;
						nextTextureIndex = 1;
						currentSceneInRotation = 1;

						// Load first scene
						params.backgroundImage = availableTextures[0];
						loadEnvironment(availableTextures[0], params.type).then((texture) => {
							currentEnvTexture = texture;
							scene.background = texture;
							scene.environment = texture;
							// Start rotation with 5-second intervals
							startBackgroundRotation();
							console.log('ðŸŽ¬ Starting 5-second rotation (first 6 scenes seamless)...');
						});
					}, 500);
				}, 500);
			}

			// Load remaining scenes in background (called during scene 6)
			async function loadRemainingScenes() {
				if (allScenesLoaded) return;

				console.log(`ðŸ”„ Loading ${remainingScenes.length} remaining scenes in background...`);

				for (let i = 0; i < remainingScenes.length; i++) {
					const sceneName = remainingScenes[i];

					// Load without blocking
					loadEnvironment(sceneName, params.type, true).then(() => {
						console.log(`  âœ… Background loaded: ${sceneName}`);
					});

					// Small delay between loads to avoid frame drops
					await new Promise(resolve => setTimeout(resolve, 100));
				}

				allScenesLoaded = true;
				console.log(`âœ… All ${availableTextures.length} scenes now loaded!`);
			}

			// Start preloading initial 6 scenes
			preloadInitialScenes();

			const gui = new GUI();

			gui.add(params, 'autoRotate');
			gui.add(params, 'autoRotateBackground').onChange((value) => {
				if (value) {
					startBackgroundRotation();
				} else {
					stopBackgroundRotation();
				}
			});
			gui.add(params, 'metalness', 0, 1, 0.01);
			gui.add(params, 'roughness', 0, 1, 0.01);
			gui.add(params, 'exposure', 0, 4, 0.01);
			gui.add(params, 'backgroundImage', availableTextures).onChange((value) => {
				// Stop auto rotation when manually changing
				stopBackgroundRotation();
				// Cancel any pending mid-interval preload and reschedule
				clearPreloadSchedule();
				// Update current index to match selection
				currentTextureIndex = availableTextures.indexOf(value);
				nextTextureIndex = (currentTextureIndex + 1) % availableTextures.length;

				loadEnvironment(value, params.type);
			});
			gui.add(params, 'type', ['HalfFloatType', 'FloatType']).onChange((value) => {
				// Clear cache when type changes
				textureCache.forEach((texture, key) => {
					texture.dispose();
				});
				textureCache.clear();
				loadingTextures.clear();

				loadEnvironment(params.backgroundImage, value);
			});

			gui.open();

			window.addEventListener('resize', onWindowResize);

		}

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;

			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

		}

		function render() {

			if (model) {
				// Update material properties for all meshes
				model.traverse(function (child) {
					if (child.isMesh) {
						child.material.roughness = params.roughness;
						child.material.metalness = params.metalness;
					}
				});
			}

			if (params.autoRotate) {

				pivotGroup.rotation.z += 0.005; // Rotate on Z-axis

			}

			renderer.toneMappingExposure = params.exposure;

			if (controls) {
				controls.update();
			}

			// Render background crossfade quad first if both textures bound
			renderer.clear();
			if (backgroundMaterial && backgroundMaterial.uniforms && backgroundMaterial.uniforms.texA.value && backgroundMaterial.uniforms.texB.value) {
				const orthoCam = new THREE.Camera();
				const bgScene = new THREE.Scene();
				bgScene.add(backgroundMesh);
				renderer.render(bgScene, orthoCam);
			}
			renderer.render(scene, camera);

		}

	</script>
</body>

</html>